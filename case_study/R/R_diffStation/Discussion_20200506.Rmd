---
title: "Follow-up meeting (20200506)"
author: "Youchen"
date: "5/6/2020"
output: slidy_presentation
---

## Study Area

![](demMap.png)

![](basin.png)


## Model Framework

res = f(input variables, pcr state variables)

* res = observations - pcrglob predictions
* predictors:
    * ~~Sign of the residuals (-/+)~~
    * Days in the year (1~365/366)
    * Input variables:
        + precipitation (p)
        + temperature (t)
        + reference potential evapotranspiration (et)

    * State variables:

State Variable   |  Unit  | Meaning
---------------- | -----  | ---------
actualET | m/day |	actual evaporation (calculated by temperature and potential evaporation, based on soil water(?))
baseflow | m/day | 	baseflow, groundwater discharge
~~channelStorage~~  |  ~~m^3^~~	 | ~~channel storage~~
directRunoff |  m/day | surface runoff
domesticWaterWithdrawal  | m/day | 	domestic water withdrawal
gwRecharge  |  m/day  |  (net) groundwater recharge, fluxes from the lower soil layer to groundwater stores
industryWaterWithdrawal |  m/day  |  industrial water withdrawal
interflowTotal  |  m/day  |  interflow, shallow sub-surface flow
irrigationWaterWithdrawal  |  m/day	 |  water withdrawal allocated for irrigation purposes
livestockWaterWithdrawal  |   m/day	 |  water withdrawal allocated for livestock demand
nonIrrWaterConsumption  |  m/day  | 	non-irrigation sectoral water demand
snowCoverSWE  | m | 	snow cover/storage in water equivalent thickness (excluding liquid part)
snowFreeWater  | m	 | liquid water/meltwater storage in the snowpack
storGroundwater  | m | 	groundwater storage (renewable part)
storLowTotal |  m  | 	S1 actual upper soil water storage
storUppTotal  | m | 	S2 actual lower soil water storage
**surfaceWaterStorage** |  m | 	surface water storage (lakes, reservoirs, rivers, and inundated water)
totalEvaporation  |  m/day | 	total evaporation (Eland+Ew)
totLandSurfaceActuaET  | m/day | 	total land evaporation


# Using default pcr parameters
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
source('function_0_loadLibrary.R')
# input:
calibrMod <- 'uncalibrated'      # calibrated    uncalibrated
# station_i <- 1                         # station id
# plotTitle <- stationInfo$plotName[station_i]
trainPeriod <- 1981:1990
testPeriod <- 1991:2000
repeatedCV <- F # whether repeated two-fold cv
```

```{r read data}
stationInfo <- read.csv('../data/rawData/stationLatLon.csv')
station <- stationInfo$station
station <- factor(station, levels = c('Basel','Maxau','Lobith','Cochem','Wuerzburg'))

if(repeatedCV){
    rf.eval <- read.csv(paste0('../data/result_', calibrMod,'/repeatedcv/rf_eval.csv'))
}else rf.eval <- read.csv(paste0('../data/result_', calibrMod,'/rf_eval.csv'))
if(repeatedCV){
    vi <- read.csv(paste0('../data/result_', calibrMod,'/repeatedcv/variable_importance.csv'))
}else vi <- read.csv(paste0('../data/result_', calibrMod,'/variable_importance.csv'))

```


## KGE and RMSE
```{r KGE,fig.width=10, fig.height=4.5}
rf.eval <- rf.eval %>%
    mutate(station=factor(station, 
                          levels = c('Basel','Maxau','Lobith','Cochem','Wuerzburg'))) %>% 
    mutate(plotTitle=factor(plotTitle,
                            levels = c('Basel (Rhine)','Maxau (Rhine)', 'Lobith (Rhine)',
                                       'Cochem (Moselle)', 'Wuerzburg (Main)')))

rf.eval_gather <- gather(rf.eval, key='key', value='value', 
                         c('KGE','KGE_corrected','RMSE','RMSE_corrected')) %>%
    mutate(gof=ifelse(grepl('RMSE', key), 'RMSE', 'KGE')) %>% 
    mutate(model=ifelse(grepl('corrected', key), 'RF-corrected', 'pcr-globwb'))


ggplot(data = rf.eval_gather, aes(x=station, y=value, fill=model))+
    geom_col(position = 'dodge')+
    facet_grid(gof~datatype, scale='free')+
    theme_gray(base_size = 16)+
    labs(title = 'Model performance at different stations', y='GOF value')+
    scale_fill_manual(values=c("#00BFC4", "#F8766D"))
    # geom_text(aes(x=station, y=value,
    #               label=round(value, digits=2)),
    #           position=position_dodge(width = 1),
    #           size=4.5)

ggplot(data = rf.eval_gather, aes(x=station, y=value, fill=model))+
    geom_col(position = 'dodge')+
    facet_grid(gof~datatype, scale='free')+
    theme_gray(base_size = 16)+
    labs(title = 'Model performance at different stations', y='GOF value')+
    scale_fill_manual(values=c("#00BFC4", "#F8766D"))+
    geom_text(aes(x=station, y=value,
                  label=round(value, digits=2)),
              position=position_dodge(width = 1),
              size=4.5)
```

## Variable importance and correlations between predictors and residuals
```{r, fig.width=15, fig.height=4, echo=F}
pList <- list()
stationOrder <- c(1,4,3,2,5)
for(id in 1:length(station)){
    station_i <- stationOrder[id]
    source('function_1_readData_excludeChannelStorage.R')
    plotTitle <- stationInfo$plotName[station_i]
    # print(plotTitle)
    imp <- vi[as.character(station[station_i])]
    imp_df <- data.frame(pred=vi$names, importance=imp) %>% 
        mutate(pred=as.character(pred))
    names(imp_df)[2] <- 'importance'
    corData1 <-  all %>% 
        group_by(datatype) %>% 
        mutate(res=(res-mean(res))/sd(res)) %>% as.data.frame() %>% 
        gather(., key='pred','value', c(all_of(feature),-'day'))
        # mutate(predtype=case_when(pred%in%snownames ~ 'snow', 
        #                           pred%in%stornames ~ 'storage',
        #                           pred%in%waternames ~ 'water',
        #                           pred%in%wdlnames ~ 'withdrawal',
        #                           pred%in%etnames ~ 'ET',
        #                           pred%in%c('t','p') ~ 'meteor'))
    
    corDatac <- corData1 %>% 
        group_by(pred) %>%      #datatype
        summarise(cor=cor(value, res), 
               corSign=ifelse(cor>0, '+', '-')) %>% 
        as.data.frame() %>% 
        inner_join(., imp_df, by='pred') %>% 
        mutate(importance=sqrt(importance))
    
    pList[[id]] <- ggplot(corDatac %>% 
               gather('key','value', c('cor','importance'))
           ) +
        geom_col(aes(reorder(pred, value), value),
                 position = 'dodge', fill='khaki') +
        # geom_col(aes(reorder(pred, importance), cor))+
        coord_flip() +
        facet_grid(.~key, scale='free')+
        labs(x='names', y='mean decrease in node impurity (sd)')+
        ggtitle(plotTitle)
        # scale_fill_discrete(name = "Station", 
        #                     labels = station[station_i])+
        # geom_text(aes(x=reorder(pred, value), y=value, 
        #               label=round(value,2)),
        #           size=3, position = position_dodge(0.1))
    
}

grid.arrange(pList[[1]], pList[[2]], pList[[3]], nrow=1)

```

## Variable importance and correlations between predictors and residuals

```{r, fig.width=10, fig.height=4}
grid.arrange(pList[[4]], pList[[5]], nrow=1)

```

## Related studies:

1. Snieder, E., Shahmansouri, A., Cheng, C.-H., Ding, Y., Graham, E., & Khan, U. (2020). “Improved real-time SWMM flow forecasts using two machine learning approaches.” Paper presented at the EGU General Assembly 2020, Vienna, Austria.
* SWMM-ANN hybrid model:  ANN corrects SWMM predictions with a lead time of 4-hour. They use  SWMM flow predictions and lagged (i.e., 1 to 24-hour lag time) rainfall and observed flow time-series as predictors to predict the difference between SWMM forecasts and flow observations. 

2. C. Kurian, K. P. Sudheer, V. Krishna Vema, and D. Sahoo, “Effective flood forecasting at higher lead times through hybrid modelling framework,” J. Hydrol., p. 124945, Apr. 2020.
* A ANN model was built by predictors of lagged precipitation observations, lagged streamflow observations, and lagged streamflow predictions from two semi-distributed hydrological models (HEC-HMS & SWAT) to predict real-time streamflow.

3. C. C. Young, W. C. Liu, and M. C. Wu, “A physically based and machine learning hybrid approach for accurate rainfall-runoff modeling during extreme typhoon events,” Appl. Soft Comput. J., vol. 53, pp. 205–216, Apr. 2017.
* A hybrid model (M4) that combines the strength of a physically-based distributed hydrological model and a data-driven model (ANN), was developed.

## Extra Information

1. Time series plots of the discharges and residuals
2. Time series plots of the predictors

```{r}

```
